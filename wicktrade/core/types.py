"""
Core data types and enums for the wick trading system.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime
import pandas as pd


class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class SignalType(Enum):
    LONG = "long"
    SHORT = "short"
    FLAT = "flat"


class PositionSide(Enum):
    LONG = "long"
    SHORT = "short"
    FLAT = "flat"


class ExitReason(Enum):
    INITIAL_TARGET = "initial_target"
    TRAILING_STOP = "trailing_stop"
    MAX_TARGET = "max_target"
    STOP_LOSS = "stop_loss"
    TREND_BROKEN = "trend_broken"
    TIME_LIMIT = "time_limit"
    MANUAL = "manual"


@dataclass
class Candle:
    """Single candlestick data point."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int

    @property
    def body_top(self) -> float:
        """Top of candle body (higher of open/close)."""
        return max(self.open, self.close)

    @property
    def body_bottom(self) -> float:
        """Bottom of candle body (lower of open/close)."""
        return min(self.open, self.close)

    @property
    def body_size(self) -> float:
        """Size of candle body in price units."""
        return abs(self.close - self.open)

    @property
    def upper_wick(self) -> float:
        """Upper wick size in price units."""
        return self.high - self.body_top

    @property
    def lower_wick(self) -> float:
        """Lower wick size in price units."""
        return self.body_bottom - self.low

    @property
    def upper_wick_pct(self) -> float:
        """Upper wick as percentage of close price."""
        return (self.upper_wick / self.close) * 100 if self.close > 0 else 0

    @property
    def lower_wick_pct(self) -> float:
        """Lower wick as percentage of close price."""
        return (self.lower_wick / self.close) * 100 if self.close > 0 else 0

    @property
    def is_bullish(self) -> bool:
        """True if close > open (green candle)."""
        return self.close > self.open

    @property
    def is_bearish(self) -> bool:
        """True if close < open (red candle)."""
        return self.close < self.open

    @classmethod
    def from_series(cls, row: pd.Series) -> "Candle":
        """Create Candle from pandas Series (DataFrame row)."""
        return cls(
            timestamp=row.name if isinstance(row.name, datetime) else pd.to_datetime(row.name),
            open=float(row["open"]),
            high=float(row["high"]),
            low=float(row["low"]),
            close=float(row["close"]),
            volume=int(row["volume"]),
        )


@dataclass
class WickStats:
    """Statistics for wick sizes within a trend."""
    min_wick: float      # Minimum wick percentage
    max_wick: float      # Maximum wick percentage
    avg_wick: float      # Average wick percentage
    std_wick: float      # Standard deviation
    median_wick: float   # Median wick percentage
    count: int           # Number of candles analyzed

    def is_valid(self, min_count: int = 3) -> bool:
        """Check if stats are based on sufficient data."""
        return self.count >= min_count and self.avg_wick > 0


@dataclass
class TrendChannel:
    """Identified trend channel with swing points."""
    trend_type: str                           # 'UPTREND' or 'DOWNTREND'
    start_idx: int                            # Index of trend start
    end_idx: int                              # Index of trend end
    swing_lows: List[Tuple[int, float]]       # [(index, price), ...]
    swing_highs: List[Tuple[int, float]]      # [(index, price), ...]
    strength: float                           # Trend strength metric (0-1)

    @property
    def length(self) -> int:
        """Number of candles in the trend."""
        return self.end_idx - self.start_idx + 1

    @property
    def is_uptrend(self) -> bool:
        return self.trend_type == "UPTREND"

    @property
    def is_downtrend(self) -> bool:
        return self.trend_type == "DOWNTREND"

    def is_valid(self, min_length: int = 5) -> bool:
        """Check if trend meets minimum requirements."""
        return (
            self.length >= min_length
            and len(self.swing_lows) >= 2
            and len(self.swing_highs) >= 2
            and self.strength > 0
        )


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    entry_price: float
    stop_loss: float
    initial_target: float               # First profit target (avg_wick)
    max_target: float                   # Maximum target (max_wick)
    confidence: float = 0.0             # Signal confidence (0-1)
    wick_stats: Optional[WickStats] = None
    trend: Optional[TrendChannel] = None
    rationale: Optional[str] = None
    timestamp: datetime = None
    strategy_name: str = "wick_strategy"

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward to max target."""
        risk = abs(self.entry_price - self.stop_loss)
        reward = abs(self.max_target - self.entry_price)
        return reward / risk if risk > 0 else 0


@dataclass
class Position:
    """Current position in a symbol."""
    symbol: str
    side: PositionSide
    quantity: float
    avg_price: float
    market_value: float
    unrealized_pnl: float
    entry_time: datetime
    signal: Optional[Signal] = None
    partial_exit_taken: bool = False
    trailing_stop_price: Optional[float] = None

    @property
    def is_open(self) -> bool:
        return self.quantity > 0 and self.side != PositionSide.FLAT


@dataclass
class Order:
    """Order to be executed."""
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: float
    price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = "day"
    order_id: Optional[str] = None
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


@dataclass
class Fill:
    """Executed trade."""
    order_id: str
    symbol: str
    side: OrderSide
    quantity: float
    price: float
    timestamp: datetime
    commission: float = 0.0
    fees: float = 0.0  # SEC/FINRA fees


@dataclass
class Account:
    """Account state and balances."""
    cash: float
    buying_power: float
    portfolio_value: float
    day_trade_count: int
    positions: Dict[str, Position]
    timestamp: datetime


@dataclass
class TradeOutcome:
    """Results of a completed trade."""
    symbol: str
    entry_time: datetime
    exit_time: datetime
    entry_price: float
    exit_price: float
    quantity: float
    side: PositionSide
    pnl: float
    pnl_pct: float
    max_adverse_excursion: float   # MAE - max loss during trade
    max_favorable_excursion: float # MFE - max profit during trade
    hold_time_seconds: int
    exit_reason: ExitReason
    strategy_name: str
    fees: float = 0.0

    @property
    def hold_time_minutes(self) -> float:
        return self.hold_time_seconds / 60

    @property
    def is_winner(self) -> bool:
        return self.pnl > 0


@dataclass
class BacktestConfig:
    """Configuration for a backtest run."""
    symbol: str
    timeframe: str
    start_date: datetime
    end_date: datetime
    initial_capital: float = 100000.0
    strategy_config: Dict[str, Any] = field(default_factory=dict)
    risk_config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class BacktestResult:
    """Results from a backtest run."""
    config: BacktestConfig
    trades: List[TradeOutcome]
    equity_curve: pd.Series
    metrics: Dict[str, float]

    @property
    def total_trades(self) -> int:
        return len(self.trades)

    @property
    def winning_trades(self) -> List[TradeOutcome]:
        return [t for t in self.trades if t.is_winner]

    @property
    def losing_trades(self) -> List[TradeOutcome]:
        return [t for t in self.trades if not t.is_winner]
